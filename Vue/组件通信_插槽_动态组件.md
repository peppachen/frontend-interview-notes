## props / $emit / v-model 双向绑定

### props(父->子)

```vue
<!-- 父组件通过 props 向子组件传递数据： -->
<Child :title="parentTitle" />
```

```ts
// 子组件：
defineProps<{ title: string }>();
```

### $emit（子 -> 父）

```ts
// 子组件通过 $emit 向父组件传递事件：
emit("update:title", "新标题");
```

```vue
<!-- 父组件监听数据 -->
<Child :title="parentTitle" @update:title="handleUpdate" />
```

### v-model（简化双向绑定）

#### v-model 使用

```vue
<!-- 默认等同于 modelValue + update:modelValue： -->
<CustomInput v-model="value" />
```

```ts
// 子组件
const props = defineProps<{ modelValue: string }>();
const emit = defineEmits(["update:modelValue"]);

const onInput = (e) => emit("update:modelValue", e.target.value);
```

#### 多个 v-model

````ts
// <!-- 自定义 prop 和 event -->
const props = defineProps<{
  title: string
  content: string
}>()

const emit = defineEmits([
  'update:title',
  'update:content',
])

// 修改值时分别触发对应事件
emit('update:title', '新标题')
emit('update:content', '新内容')
``
```vue
<!-- 使用 -->
<MyInput v-model:title="title" v-model:content="content" />
````

## $attrs / $listeners 实现透传

**常用于封装组件时传递 class、style、事件等。**

> 适用于中间组件需要将 props 和事件继续传递到子组件。

```vue
<component v-bind="$attrs" v-on="$listeners" />
```

> **Vue3 中统一为 $attrs（包含所有非 prop 的 attributes 和事件）：**

- 简化组件传参逻辑，避免分别传 `$attrs、$listeners`
- 鼓励通过 `defineEmits` 显式定义事件，类型更清晰

```vue
<component v-bind="$attrs" />
```

```ts
const attrs = useAttrs();
```

## provide / inject 跨层级通信

**适用于祖先组件向任意后代组件传递数据，不依赖 props 传递链。**

```ts
// 📌 使用场景：UI 库组件通信、表单组件联动、主题样式传递。

// provide(祖先)
provide("theme", "dark");

// inject（后代）
const theme = inject("theme", "light"); // 第二个参数是默认值
```

## 插槽

### 默认插槽

```vue
<slot />

<BaseCard>默认内容</BaseCard>
```

### 具名插槽

```vue
<!-- 设置name -->
<slot name="header" />

<BaseCard>
  <template #header>标题</template>
</BaseCard>
```

### 作用域插槽

**作用域插槽的本质是一个函数,返回插槽内容的 VNode。**

#### 优势

- 子组件可以将内部数据暴露给父组件使用
- 父组件可灵活定义插槽内容，实现组件复用性更强
- 常见于表格组件、自定义渲染、弹窗 slot 等场景

```vue
<!-- 携带数据 -->
<slot name="default" :user="user" />

<BaseCard v-slot="{ user }">
  {{ user.name }}
</BaseCard>
```

## 动态组件<component :is="compName" />

```vue
<component :is="currentTab" />
```

## 组件缓存 <keep-alive>

### 基本概念

- `<keep-alive>` 是 Vue 内置组件，用于缓存动态组件或页面，使其状态不被销毁。
- 常用于切换页面时**保留组件状态、DOM 和数据**。

```vue
<keep-alive>
  <component :is="currentView" />
</keep-alive>
```

### 常用属性

| 属性      | 说明                                    |
| --------- | --------------------------------------- |
| `include` | 要缓存的组件名或正则                    |
| `exclude` | 不缓存的组件名或正则                    |
| `max`     | 最多缓存组件实例数，超过时 LRU 策略淘汰 |

```vue
<keep-alive :include="['PageA', 'PageB']" :max="10">
  <router-view />
</keep-alive>
```

⚠️ 注意：缓存依赖组件的 `name`，必须定义正确（使用 `defineOptions({ name })`）。

### 生命周期钩子

- `activated`：组件被激活（从缓存中恢复）时触发。
- `deactivated`：组件被缓存（离开视图）时触发。

```ts
onActivated(() => {
  // 每次重新进入页面时触发
});

onDeactivated(() => {
  // 页面被缓存前触发
});
```

### 配合路由缓存页面

```vue
<keep-alive :include="cachedViews">
  <router-view v-if="isRouterAlive" />
</keep-alive>
```

- `cachedViews` 来自 Pinia / Vuex / ref
- 控制缓存更新可使用 `key` 或清空 `cachedViews`

### 动态组件缓存技巧

```vue
<keep-alive>
  <component :is="tabName" :key="tabName" />
</keep-alive>
```

- 用 `key` 可以控制组件强制重建

### 常见坑点

| 问题                        | 说明                                                  |
| --------------------------- | ----------------------------------------------------- |
| 组件未缓存成功              | 原因：组件 `name` 未定义或与 `include` 不匹配         |
| 缓存后组件状态不同步        | 解决：使用 `activated` 处理重新赋值                   |
| keep-alive 缓存导致性能下降 | 控制缓存组件数量 + 合理使用 `max` 和 `exclude`        |
| 多级嵌套路由组件缓存失效    | 要确保每一级 `router-view` 都包裹在 `<keep-alive>` 中 |
