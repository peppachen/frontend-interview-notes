## Vue vs React 对比

> 1. 基于原生 ES Module：
>    Vite 利用浏览器原生支持的 ES Module 加载机制进行开发，无需像 Webpack 一样打包整个项目，因此在开发模式下启动非常迅速。
> 2. 依赖预构建（Pre-bundling）：
>    Vite 会使用 esbuild 对依赖进行预构建，提高冷启动速度。比如我们在项目中首次构建时间从 20s 降到了 5s
> 3. 模块热更新（HMR）：
>    Vite 通过内嵌缓存机制和按需更新的方式，只重新加载被修改的模块，大大提升了开发时的热更新效率。
> 4. 构建优化：
>    在生产构建中，Vite 底层使用 Rollup，我在项目中通过配置 SplitChunks、按需加载、Tree-shaking 等手段，最终将首屏资源体积压缩了 35%，并把构建时间从 12s 降到了 9s。
>    同时配置了 define 全局变量、alias 路径别名、动态导入（import()）等优化方式。

### 一、核心对比表格

| 维度           | Vue（特别是 Vue3）                                  | React（特别是 Hooks/Fiber 架构） |
| -------------- | --------------------------------------------------- | -------------------------------- |
| **设计理念**   | 渐进式框架（MVVM）                                  | 纯视图层库（函数式组件）         |
| **语法结构**   | Options API / Composition API                       | Function Component + Hooks       |
| **模板语法**   | HTML 模板 + 指令（v-if、v-for）                     | JSX（JavaScript XML）            |
| **响应式原理** | Vue2: `Object.defineProperty`<br>Vue3: `Proxy`      | `setState` + immutable 数据流    |
| **状态管理**   | Vuex / Pinia                                        | Redux / Context                  |
| **组件通信**   | props / emits / provide-inject                      | props / Context / Redux          |
| **生命周期**   | created / mounted / updated 等<br>Vue3: `onMounted` | useEffect / useLayoutEffect      |
| **Diff 算法**  | 双端对比 + key + LIS + patchFlag                    | Fiber 架构链表遍历 + 优先级调度  |
| **性能优化**   | 编译时静态提升 / patchFlag 动态标记                 | memo / useCallback / useMemo     |
| **SSR 支持**   | Nuxt.js                                             | Next.js                          |
| **构建工具**   | Vue CLI / Vite                                      | CRA / Vite / Webpack             |
| **生态**       | 官方统一工具链完善                                  | 社区丰富，第三方生态强           |
| **学习曲线**   | 模板语法易上手                                      | 逻辑更灵活，工程化更强           |
| **典型场景**   | 中后台系统 / 大型表单 / CMS                         | WebApp / 跨平台（React Native）  |

### 二、总结话术

> Vue 更适合强调开发效率和响应式交互的项目，Composition API 提升了逻辑复用性；React 更倾向自由组合的函数式架构，Fiber 架构实现了可中断调度机制，更适合构建复杂交互和高并发场景。二者各有优势，应结合业务需求选择。

## Vue3 和 Vue2 的核心区别？

### 答题思路

```txt
  Vue3 在保持 Vue2 响应式编程理念的同时，引入了 Composition API 和 Proxy 新架构，大幅提升了组件逻辑复用性和性能表现。同时对 TypeScript 支持更完善，打包更小，启动更快，适合大型项目开发。对比 Vue2 的 Options API，Vue3 更具现代化、模块化的架构设计。
```

### 1. 响应式系统实现不同

- `vue2` 使用 `object.defineProerty`,只能劫持已有属性,需手动深度监听(如数组)
- `vue3` 使用 `proxy` 可动态拦截属性添加删除,支持深层次嵌套结构,解决了 Vue2 中属性新增/删除监听不到的问题

### 2. 新增 Compostion API (组合式 API)

- `vue2`使用 data(),methods,computed,wathch 等分散配置
- `vue3`引入 seetup()函数,允许将相关逻辑聚合组织;更易于逻辑复用

### 3. 生命周期变化

| Vue2          | vue3              |
| ------------- | ----------------- |
| created       | setup()           |
| moutend       | onMoutend()       |
| beforeDestroy | onBeforeUnmount() |

### 4. 模板编译和指令处理变化

- `静态提升、patchFlag 打标、事件缓存、Block Tree 分组等手段`，最大程度减少运行时的遍历和 patch 操作
- v-if 和 v-for 优先级不同
  - `vue2`:v-for 优先于 v-if
  - `vue3 `:v-if 优先,避免无意义的循环
- 新增〈script setup>语法糖,减少模板代码冗余

### 5. 性能优化

- 默认支持`Tree-shaking`,体积更小
- 更快的渲染机制(compiler 优化+Proxy)
- 更好的 TypeScript 支持

### setup()中为什么不能使用 this?

- `setup()`在整个生命周期中优先级最高,在**组件实例创建之前执行的**，此时组件实例（即 this）尚未被完全初始化;
- `setup()`用于逻辑组织和组合的函数,所有的数据、props、methods 都通过函数参数解构或返回值暴露，**不再依赖 this 上的绑定**。

#### 答题思路

```txt
 “因为 setup() 是在组件实例创建之前执行的，因此此时还没有 this 可用。Vue3 推崇函数式逻辑组合方式，因此不再依赖 this，而是通过参数解构和返回对象来使用 props、emit 和响应式数据。这也是 Composition API 更具逻辑复用性和类型推导优势的重要体现。
```

## data 中为什么不能直接调用 methods 中方法

### 原因

> **在 data 定义中访问 this.methodName() 是 undefined 或报错的。**
> Vue 实例的初始化顺序是先初始化 data，再挂载 methods，此时 methods 尚未挂载到 this 上，data() 里访问 this.methodName() 会导致 undefined 或运行时错误。

### 解决方案

1. 使用 created() 生命周期中初始化：

```js
data() {
  return {
    message: ''
  }
},
methods: {
  getMessage() {
    return 'hello'
  }
},
created() {
  this.message = this.getMessage()
}
```

2. 用 computed 替代：

如果值是依赖于其它状态计算得出，不建议放 `data`，用 `computed` 更合理：

```js
computed: {
  message() {
    return this.getMessage()
  }
}
```

### 补充延伸点：

> Vue 的生命周期是从 beforeCreate → created → mounted 开始的。
>
> - 在 beforeCreate 阶段，data 和 methods 都尚未挂载；
> - 在 created 之后，data 和 methods 才完整挂载，可用于初始化。

## Vue2 和 Vue3 响应式的区别

### Vue2(object.defineProerty)

- 遍历递归对象,对每个属性单独设置` getter``setter `,性能开销较大;
- **无法动态监听属性变化(增删)**,对象属性变化时不会触发视图更新，需通过 `Vue.set` 或 `Vue.delete` **手动处理**;
- 无法直接监听数组索引的修改（如 `arr[0] = 1` ）和 `length` 变化;
- 只能支持代理普通对象和数组,不支持 `Map`、`Set` 等复杂数据结构。

### Vue3(Proxy)

- `Proxy` 可以直接代理整个对象，因此可以监听属性的**动态增删**，不再需要手动操作。
- 能够直接监听数组索引的修改（如 `arr[0] = 1` ）以及 `length` 变化。
- 采用懒代理模式,只有在访问属性时才会递归代理子对象,避免了递归遍历的性能开销。
- 支持更多数据结构,除了普通对象数组,`Proxy`还可以代理 `Map`、`Set` 等复杂数据结构。

## Vue2 升级 Vue3 如何实现?遇到的问题,如何解决?

Vue3 在性能、响应式系统、TS 支持、逻辑复用等方面较 Vue2 有显著提升，因此希望在不影响业务交付的前提下，将项目平滑迁移到 Vue3。

### 二、升级整体流程（渐进式迁移策略）

1. **依赖升级**

   - 升级 Vue2 → Vue3 (`vue@next`)
   - 升级 Vue Router（v3 → v4）、Vuex（或替换为 Pinia）

2. **构建工具改造**

   - Webpack → Vite
   - 替换 vue-loader、配置支持 `<script setup>`、TS 模块

3. **逐步重构组件**

   - 选取低风险模块做试点
   - 逐步将 Options API 重构为 Composition API

4. **重写 mixins / 插件**
   - 将 mixin 改写为 composable 函数
   - 用 props 和 emit 替代 this

---

### 三、常见问题与解决方案

| 问题类型            | 描述                                | 解决方案                                   |
| ------------------- | ----------------------------------- | ------------------------------------------ |
| 生命周期变化        | `beforeDestroy` → `onBeforeUnmount` | 使用组合式生命周期 API                     |
| `this` 失效         | setup() 中 `this` 为 undefined      | 用 `setup(props, { emit })` 替代访问方式   |
| 第三方库不兼容      | 如 ElementUI 不支持 Vue3            | 替换为 Element Plus / Naive UI             |
| `$listeners/$attrs` | 属性合并行为变化                    | 审查透传逻辑，适配 Vue3 的新继承机制       |
| 全局 API 变化       | Vue2 的 `Vue.use()` 等方法          | 替换为 `createApp().use()`                 |
| TS 类型变化         | 类型声明方式不同                    | 使用 `defineComponent` + `withDefaults` 等 |

### 四、优化方案

- 使用官方兼容包：[@vue/compat](https://github.com/vuejs/vue-compat)
- 编写单元测试确保迁移后功能一致
- 每次迁移拆解为小任务，利于回滚
- 重构逻辑同步更新团队协作方式与代码规范

### 五、答题思路

```txt
“我参与了公司后台系统从 Vue2 到 Vue3 的升级，采用渐进式迁移策略。首先升级了核心依赖和构建工具，将 Webpack 替换为 Vite，并用 `defineComponent + setup` 改写核心模块逻辑。过程中遇到最大的问题是一些 mixin 无法直接替换为 hooks，我将其重构为 composable，并通过单元测试确保功能一致性。最终项目构建速度提升了 40%，逻辑更清晰，维护成本也降低了。”
```

#### 生命周期发生变化迁移优化策略

##### 一、生命周期对照表

| Vue2 生命周期 | Vue3 替代 API     | 执行阶段            |
| ------------- | ----------------- | ------------------- |
| beforeCreate  | —（合并进 setup） | 组件实例初始化前    |
| created       | —（合并进 setup） | 组件创建后          |
| beforeMount   | onBeforeMount     | DOM 挂载前          |
| mounted       | onMounted         | DOM 挂载后          |
| beforeUpdate  | onBeforeUpdate    | 更新前              |
| updated       | onUpdated         | 更新后              |
| beforeDestroy | onBeforeUnmount   | 卸载前              |
| destroyed     | onUnmounted       | 卸载后              |
| activated     | onActivated       | `<keep-alive>` 激活 |
| deactivated   | onDeactivated     | `<keep-alive>` 失活 |

##### 二、组合式 API 替代写法示例

###### ✅ Vue2 示例（Options API）

```js
export default {
  created() {
    this.init();
  },
  mounted() {
    this.fetchData();
  },
  beforeDestroy() {
    this.cleanUp();
  },
};
```

###### ✅ Vue3 示例（Composition API）

```ts
import { onMounted, onUnmounted } from "vue";

export default {
  setup(props, { emit }) {
    const fetchData = () => {
      /* 获取数据 */
    };
    const cleanUp = () => {
      /* 卸载清理 */
    };

    onMounted(() => {
      fetchData();
    });

    onUnmounted(() => {
      cleanUp();
    });

    return {
      /* 暴露组件内容 */
    };
  },
};
```

##### 三、具体迁移解决策略总结

- ✅ **created/beforeCreate → setup() 中初始化逻辑**
  - 这两个钩子合并到 setup() 中，初始化逻辑直接写在顶层。
- ✅ **beforeDestroy/destroyed → onBeforeUnmount/onUnmounted**
  - 可用于解绑事件、清理副作用等。
- ✅ **生命周期调用顺序不变**
  - Vue3 的生命周期钩子只是名称变化，时机本质和 Vue2 一致。
- ✅ **组合式函数中可封装生命周期逻辑**
  - 可以在 composable 中使用生命周期，增强复用性。

```ts
// useWebSocket.ts
export function useWebSocket() {
  onMounted(() => {
    connect();
  });
  onUnmounted(() => {
    disconnect();
  });
}
```

##### 四、答题思路

```txt
 “Vue3 生命周期用组合式 API 表达更清晰。原本写在 created 或 mounted 中的初始化逻辑现在直接写在 setup 顶层，卸载相关逻辑用 onUnmounted 替代 beforeDestroy。我在项目中会将常见逻辑封装进 composable，比如 usePolling 或 useWebSocket，使生命周期控制更集中、易复用。”
```

### 如何处理 Vue2 中的组件通信逻辑？

### Mixin 如何迁移为 Composition API？

#### 一、🌱 为什么要迁移 mixin？

Vue2 中的 mixin 虽然可以实现逻辑复用，但存在以下问题：

| 问题           | 描述                           |
| -------------- | ------------------------------ |
| 命名冲突风险   | 多个 mixin 的方法/变量容易重名 |
| 逻辑来源不清晰 | 方法来自哪里难以追溯           |
| 类型提示缺失   | 对 TypeScript 支持较差         |
| 可测试性弱     | 不易单元测试和复用             |

#### 二、🌟 Vue3 推荐使用 `composable` 替代 mixin

Composition API 提倡逻辑复用通过**函数抽离（composable）**实现。

> Composable 是一个普通的函数，内部使用 `ref`、`computed`、`watch`、生命周期钩子等组合式 API，将逻辑抽象封装。

#### 三、🚀 Mixin → Composable 的迁移步骤

1. **分析 mixin 的内容**

   - `data` → 转为 `ref` 或 `reactive`
   - `methods` → 普通函数
   - `computed` → `computed()`
   - `watch` → `watch()`
   - `生命周期钩子` → `onXXX()`

2. **创建 `useXXX()` 函数**

3. **在组件中使用**

#### 四、🧩 示例：从 mixin 到 composable

##### ✅ Vue2 中的 mixin：

```js
// loggerMixin.js
export default {
  data() {
    return { logCount: 0 };
  },
  methods: {
    log(msg) {
      this.logCount++;
      console.log(`[${this.logCount}] ${msg}`);
    },
  },
  mounted() {
    this.log("组件已挂载");
  },
};
```

##### ✅ Vue3 中的 composable：

```ts
// useLogger.ts
import { ref, onMounted } from "vue";

export function useLogger() {
  const logCount = ref(0);
  const log = (msg: string) => {
    logCount.value++;
    console.log(`[${logCount.value}] ${msg}`);
  };

  onMounted(() => {
    log("组件已挂载");
  });

  return { log, logCount };
}
```

##### ✅ 组件中使用：

```ts
import { useLogger } from "./useLogger";

export default {
  setup() {
    const { log } = useLogger();
    log("手动调用日志");

    return {};
  },
};
```

#### 五、🗣️ 答题思路

> “Vue3 中我会将 Vue2 的 mixin 逻辑迁移为 `composable` 函数，比如把日志记录逻辑抽象为 `useLogger`，用 `ref` 替代 data，函数内部使用生命周期钩子，比如 `onMounted`。这样做的好处是逻辑来源明确、命名冲突避免，并且可以独立测试和复用，在团队项目中效果非常好。”

### composable 和 mixin 的异同（Vue 面试常考）

#### 一、🌱 相同点

| 相同点             | 描述                                                   |
| ------------------ | ------------------------------------------------------ |
| 逻辑复用           | 都用于复用组件间的逻辑，比如轮询、事件监听、数据同步等 |
| 可在多个组件中使用 | 可跨组件共享功能                                       |
| 可以访问生命周期   | 都可以访问生命周期钩子控制逻辑时机                     |

---

#### 二、🚧 不同点对比

| 维度           | mixin（Vue2）                             | composable（Vue3）                           |
| -------------- | ----------------------------------------- | -------------------------------------------- |
| 本质           | 一个对象（包含 data/methods/computed 等） | 一个函数（返回响应式对象或函数）             |
| 使用方式       | 通过 `mixins: [xxMixin]` 注入             | 在 `setup()` 中直接调用：`useXxx()`          |
| 命名冲突       | 容易冲突（多个 mixin 合并到 this）        | 不会冲突（作用域封闭、变量自定义）           |
| 逻辑来源清晰度 | 差（方法来自哪个 mixin 不清楚）           | 清晰（从哪个 `useXXX()` 函数引入一目了然）   |
| 类型支持       | 差，TS 推导困难                           | 好，组合式 API 完全支持 TypeScript           |
| 调试能力       | 弱（this 上挂载很多不可见字段）           | 强（每个 composable 可独立调试、单元测试）   |
| 生命周期使用   | 写在组件中                                | 可在函数中使用生命周期钩子（如 `onMounted`） |
| 可测试性       | 差（全局混入不易单测）                    | 好（函数可单元测试、Mock、复用）             |

#### 三、🗣️ 答题思路

> “Mixin 是 Vue2 中常见的逻辑复用手段，但在实践中容易出现命名冲突、来源不明、类型难推导等问题。而 Vue3 的 composable 是基于 Composition API 的函数抽象方式，支持封装逻辑并返回响应式数据，不仅逻辑聚合清晰、变量作用域隔离，而且对 TypeScript 更友好，也方便测试和调试。在项目中我已经将常用 mixin 全部重构为 composable 函数，例如 usePolling、useLogger、useForm 等。”

### 如何保障升级过程中的线上稳定性？

#### 一、🧭 升级策略：渐进式迁移

- 拆分模块，优先升级非核心、非高流量页面
- 使用官方的兼容包 `@vue/compat` 实现 Vue2/3 混合运行
- 支持 Vue2 与 Vue3 并存（如 monorepo 或微前端架构）
- 分阶段替换组件与逻辑，逐步稳定替换关键路径

#### 二、🧪 自动化测试保障

| 类型     | 目标                                   |
| -------- | -------------------------------------- |
| 单元测试 | 保证核心逻辑函数和 composable 正确执行 |
| 组件测试 | 校验 props、事件、UI 行为是否一致      |
| E2E 测试 | 验证完整业务流程（如 登录 → 下单）     |

- 对升级模块补全测试覆盖率
- 升级前后运行测试集，确保功能无回归

#### 三、🔍 比对机制与双产线校验

- 新旧页面并存（如 /page-vue2 与 /page-vue3）
- 埋点监控或行为统计对比页面数据差异
- 可采用“影子发布”方式，业务无感知下测试 Vue3 页面表现

#### 四、📡 日志与监控体系

- 接入前端错误监控工具（如 Sentry）
- 接入性能埋点（如 FCP、LCP、JS 错误、白屏率等）
- Vue3 页面异常统一上报：白屏、网络异常、组件渲染失败等

#### 五、🧯 回滚策略与灰度发布

- 每次构建记录版本快照，支持快速版本回滚
- 灰度策略控制升级用户比例，逐步扩大范围
- 高优先级页面上线前先内测 / 小流量用户使用

#### 🎤 答题思路

> “在 Vue2 升级 Vue3 的过程中，我采用渐进式迁移方式，通过功能分包、双版本共存、可控灰度上线，保障升级风险。配合单元测试与 E2E 用例回归，确保功能一致性。我们还接入了 Sentry 做前端异常监控，并设置了版本快照回滚策略，一旦发现问题可在 5 分钟内切回旧版本，有效降低了升级风险。”

## 为什么 Vue2 不能被监听属性变化？如何解决？

**常见不可被监听的类型**
新增/删除对象属性、数组索引/数组长度、原始类型（`string、number` 等）、`Object.freeze()` 的对象、使用 Object.defineProperty 的对象

### 原因

**Vue2 使用的是 Object.defineProperty 对数据进行劫持，但它有几个限制：**

- 不能监听新增属性（需用 Vue.set）
- 不能监听数组索引和长度变化
- 深层嵌套对象需递归遍历，性能差
- 劫持的是属性，不是对象整体，扩展性差

### 解决方案

1. 使用 Vue.set

```js
this.$set(this.arr, index, newValue);
//等价于
Vue.set(this.arr, index, newValue);
```

2. 使用 splice

   ```js
   /**
    * splice 是 Vue2 代理过的方法，能触发视图更新；
    * 内部重写了 Array.prototype.splice，触发响应式更新。
    */
   this.arr.splice(index, 1, newValue);
   ```

3. 升级 Vue2
   **Vue3 使用 Proxy 实现响应式,可以完整的拦截数组的所有操作**
   - 一次性代理,懒加载(按访问时触发)子对象
   - 可以监听新增/删除属性
   - 数组索引的读写
   - 数组长度变化
   - 遍历类操作

### 扩展问题

#### Vue.set 和 this.$set 的区别

| 项目     | Vue.set                                        | this.$set                   |
| -------- | ---------------------------------------------- | --------------------------- |
| 定义位置 | 全局 API (Vue 构造函数上)                      | 实例方法 (Vue.prototype 上) |
| 使用范围 | 任何地方（不依赖于组件实例）                   | 必须在组件实例中使用        |
| 典型用法 | Vue.set(obj, key, val)this.$set(obj, key, val) |
| 内部实现 | 都是调用同一个核心方法 \_set()                 | 本质上是对 Vue.set 的封装   |

## v-show 和 v-if 的区别

- **渲染方式：**
  💡v-if：条件为 true 时才会渲染元素，条件为 false 时销毁元素。
  💡v-show：始终渲染元素，只是通过 CSS 控制 `display 属性`来显示或隐藏。
- **适用场景：**
  💡v-if：适用于条件变化不频繁的场景。
  💡v-show：适用于条件变化频繁的场景。

## 为何 v-if 和 v-for 不能一起使用？

`v-if` 和 `v-for` 不能直接一起使用的原因，主要是因为它们在 **解析优先级** 和 **逻辑处理** 上存在冲突。

由于`v-for` 的解析优先级高于 `v-if`，同时使用 v-if 和 v-for，Vue 首先会循环创建所有 dom 元素，然后根据条件来判断是否渲染每个元素，这种方式可能导致 Vue 进行大量的 DOM 操作，性能较差。其次，`v-for` 会为每个循环项创建一个新的作用域，而 `v-if` 的条件如果依赖于这个作用域内的数据，可能导致判断逻辑异常。

为避免上述问题，vue 官方推荐我们将 `v-if` 放到 `v-for` 外层，或者将 `v-if` 放置到 `v-for` 内部的单个节点上。

```js
<div v-if="show">
  <div v-for="item in list" :key="item.id">{{ item.name }}</div>
</div>
```

## computed 和 watch 有什么区别

**computed**用于计算基于响应式数据的值，并缓存结果:

```vue
<template>
  <div>
    <p>原始值：{{ count }}</p>
    <p>计算后的数值：{{ doubledCount }}</p>
  </div>
</template>

<script setup>
import { ref, computed } from "vue";

const count = ref(2);

// 计算属性
const doubledCount = computed(() => count.value * 2);
</script>
```

**watch**用于监听数据变化并执行副作用操作

```vue
<template>
  <div>
    <p>原始数值：{{ count }}</p>
    <button @click="count++">增加数值</button>
  </div>
</template>

<script setup>
import { ref, watch } from "vue";

const count = ref(0);

// 监听器
watch(
  count,
  (newVal, oldVal) => {
    console.log(`数值从 ${oldVal} 变为 ${newVal}`);
  },
  // 立即生效immdiate
  //深度监听deep
);
</script>
```

| 特性 | `computed` | `watch` |
| | | -- |
| **用途** | 用于计算基于响应式数据的值，并缓存结果 | 用于监听数据变化并执行副作用操作 |
| **返回值** | 返回计算结果 | 不返回值，执行副作用 |
| **缓存机制** | 只有在访问时才会计算，会缓存计算结果，仅当依赖变化时重新计算 | 数据变化时立即执行回调，不缓存，每次数据变化都会触发回调 |
| **适用场景** | 计算派生数据，避免不必要的重复计算 | 执行异步操作、处理副作用操作，如 API 请求 |
| **性能** | 性能较好，避免重复计算 | 每次数据变化时都会执行回调函数 |

## watch 和 watchEffect 的区别

### 依赖追踪方式

`watch` ：需要**显式声明依赖，**监听指定的数据源\*\*；可以监听多个数据源或进行深度监听。

```js
import { watch, reactive } from "vue";
const state = reactive({
  count: 0,
});
watch(
  () => state.count, // 显式声明监听的依赖
  (newCount, oldCount) => {
    console.log(`新值 ${newCount} 老值 ${oldCount}`);
  },
);
```

`watchEffect` ：会自动追踪 **作用域内所有的响应式依赖**，不需要显式声明依赖。

```js
import { watchEffect, reactive } from "vue";
const state = reactive({
  count: 0,
});
watchEffect(() => {
  console.log(`Count 变化了: ${state.count}`); // 自动追踪 `state.count`
});
```

### 执行时机

`watch` ：在监听的响应式数据变化后立即执行。

`watchEffect` ：在 **组件挂载时** 执行一次副作用，并在 **依赖发生变化时** 再次执行。

### 适用场景

`watch` ：适用于 **监听特定数据** 变化并执行副作用的场景，如 API 请求、保存操作等。适合需要 **访问新值和旧值** 进行比较的场景。

`watchEffect` ：不需要访问旧值，适用于 **自动追踪多个响应式依赖** 的副作用，如渲染、自动保存等。

## 如何设计实现一个通用组件？

### 组件设计原则

| 原则     | 说明                                  |
| -------- | ------------------------------------- |
| 接偶性   | 尽量使用 props、emit,避免耦合业务逻辑 |
| 插槽化   | 用 slot 提供内容插槽，提高定制能力    |
| 配置化   | 灵活使用 props 配置项                 |
| 类型安全 | 使用 TypeScript 进行类型约束          |
| 语义清晰 | 命名规范、功能单一                    |

### 实践案例 - Modal 弹窗

```vue
<!-- 支持插槽、props控制、事件通知 -->
<!-- components/BaseModal.vue -->
<template>
  <div v-if="visible" class="modal-mask">
    <div class="modal-container">
      <header class="modal-header">
        <slot name="header">
          <h3>{{ title }}</h3>
        </slot>
        <button @click="$emit('close')">×</button>
      </header>

      <section class="modal-body">
        <slot />
      </section>

      <footer class="modal-footer">
        <slot name="footer">
          <button @click="$emit('close')">关闭</button>
          <button @click="$emit('confirm')">确定</button>
        </slot>
      </footer>
    </div>
  </div>
</template>

<script lang="ts" setup>
defineProps<{
  visible: boolean;
  title?: string;
}>();

defineEmits<{
  (e: "close"): void;
  (e: "confirm"): void;
}>();
</script>

<style scoped>
/* 简单样式 */
.modal-mask {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.3);
}
.modal-container {
  background: white;
  padding: 20px;
  margin: 10% auto;
  width: 400px;
  border-radius: 10px;
}
</style>
```

### 使用组件

```vue
<template>
  <button @click="show = true">打开弹窗</button>

  <BaseModal
    :visible="show"
    title="删除确认"
    @close="show = false"
    @confirm="handleConfirm"
  >
    <template #default>
      <p>确定要删除该项吗？</p>
    </template>
    <template #footer>
      <button @click="show = false">取消</button>
      <button class="danger" @click="handleConfirm">删除</button>
    </template>
  </BaseModal>
</template>

<script setup lang="ts">
import { ref } from "vue";
import BaseModal from "@/components/BaseModal.vue";

const show = ref(false);
const handleConfirm = () => {
  console.log("确认删除");
  show.value = false;
};
</script>
```

### 扩展问题

#### 如何避免组件频繁的性能问题

1. 减少不必要的响应式依赖

   - 使用 shallowRef/shallowReactive 减少深层监听
   - 使用 computed 避免重复计算
   - 合理拆分 watch,避免过度监听

2. 使用 defineOptions({name})+defineExpose()精简暴露

   - 避免将整个内部状态暴露给父祖件,降低耦合

3. 使用 v-memo

```vue
<!-- 在子组件渲染结构不变的情况下避免重复渲染 -->
<template v-memo="[props.a, props.b]">
  <HeavyComponent />
</template>
```

4. 使用 keep-alive + include/exclude

   - 缓存组件避免重新创建（注意配合组件名一致性）。

5. 滚动、列表场景使用虚拟滚动（如 vue-virtual-scroller）
6. 延迟加载不常用子组件（路由懒加载或组件异步加载）

#### 多个兄弟组件如何通信

##### 方案 1：使用父组件中转（推荐）

```vue
<!-- Parent.vue -->
<SiblingA @eventA="handleA" />
<SiblingB :dataFromA="data" />
```

##### 方案 2：使用中间事件总线（小项目）

```ts
// bus.ts
import mitt from 'mitt';
export const eventBus = mitt();

// SiblingA.vue
eventBus.emit('fromA', value);

// SiblingB.vue
eventBus.on('fromA', (val) => { ... });
```

##### 方案 3：使用 provide / inject

> 适用于层级较深、广播式的状态共享场景（如主题切换、权限信息等）。

#### 如何缓存组件

##### 使用 <keep-alive> 缓存组件实例

```vue
<keep-alive include="MyPageA,MyPageB">
<component :is="currentView" />
</keep-alive>
```

> 组件 name 必须定义正确（或使用 defineOptions({ name: 'MyPageA' })）。

###### 扩展问题

1. keep-alive 的工作原理？

> 缓存组件的 vnode 实例，避免重新创建和销毁。

2. 为什么缓存组件需要 name？

> include/exclude 属性依赖组件名匹配。

3. 使用 keep-alive 后组件生命周期怎么变化？

> 创建时仍会执行 setup，但切换时不会执行 unmounted，而是 deactivated。

4. 你是如何实现页面级缓存的？

> 路由 meta.keepAlive 控制缓存组件名 + <keep-alive> 包裹 router-view。

5. 如何强制刷新已缓存组件？

> 给 component 加 :key="uniqueId" 使其重新渲染。

##### 动态缓存（缓存逻辑由业务控制）

```vue
<keep-alive :include="cachedViews">
  <router-view />
</keep-alive>
```

```ts
// cachedViews: string[]，动态控制缓存页面
onMounted(() => {
  cachedViews.value.push("SomeViewName");
});
```

##### 缓存组件局部状态：Pinia + localStorage

> 即使路由跳转组件被销毁，也能恢复组件状态。

## Vue 项目打包后白屏可能有哪些原因？

```txt
从资源路径、路由模式、JS 报错、环境变量等方面逐项排查：
	•	首先确认 publicPath 是否正确，资源是否能正常加载；
	•	检查路由模式是否和服务器配置匹配，是否配置 fallback；
	•	打开控制台查看是否有 JS 报错，定位问题组件；
	•	检查打包环境变量和接口地址是否正确；
	•	添加 loading 动画与错误捕获，提升用户体验与可维护性。
```

### 常见原因及解决方案

| 问题类型             | 描述                                   | 解决方案                                   |
| -------------------- | -------------------------------------- | ------------------------------------------ |
| 静态资源路径错误     | 打包后自愿地址不对(如找不到 JS/CSSs)   | 设置正确的 publicPath（base）              |
| 路由模式配置错误     | 使用 history 模式单服务器配置 fallback | 推荐使用 hash 模式,或者配置 nginx fallback |
| Js 执行报错          | 打包后的代码出错导致页面中断           | 开启 sourceMap 调试、捕获错误日志          |
| 第三方依赖未正确引入 | CDN 或动态加载失败                     | 检查网络请求或静态资源路径                 |
| 环境变量错误         | 打包使用了错误的环境变量               | 检查 .env.production 配置                  |
| 首页 index.html 缓存 | 浏览器缓存旧版本资源或 HTML            | 清除浏览器缓存，使用版本号控制缓存         |

### 排查方案

1. 检查资源路径是否正确
   > 错误表现： 控制台报错 Failed to load resource: the server responded with a status of 404，资源路径错误。
   - Vue CLI 项目：
     ```ts
     // vue.config.js
     module.exports = {
       publicPath: process.env.NODE_ENV === "production" ? "./" : "/",
     };
     ```
   - Vite 项目
     ```ts
     // vue.config.js
     export default defineConfig({
       base: "./",
     });
     ```
2. 路由模式处理

   > **建议开发阶段使用 createWebHashHistory() 规避部署配置问题。**如果使用的是 createWebHistory()（Vue Router history 模式），需确保服务器配置了 fallback 重定向至 index.html：

   ```nginx
    location / {
    try_files $uri $uri/ /index.html;
    }
   ```

3. 报错定位 + 异常捕获
   > 打包时开启 sourceMap 便于调试：
   ```ts
   // vue.config.js
   module.exports = {
     productionSourceMap: true,
   };
   ```
   > 控制台查看报错信息，常见如：
   ```txt
   Uncaught TypeError: Cannot read properties of undefined
   Failed to execute 'appendChild'...
   ```
   > 推荐添加全局错误捕获：
   ```ts
   app.config.errorHandler = (err, vm, info) => {
     console.error("全局异常：", err, info);
   };
   ```
4. 检查环境变量

   > Vue CLI 项目 .env.production 中是否配置错误？

   ```env
   VUE_APP_API_URL=https://api.example.com
   ```

   > 确保打包命令使用的是生产环境：

   ```env
   npm run build
   ```

5. 检查是否用了 CDN 或懒加载失败
   ```html
   <script src="https://cdn.jsdelivr.net/npm/vue@3.2.47"></script>
   ```
6. 增强调试与用户体验建议

- 添加 loading 动画：
  ```html
  <div id="app">
    <div id="loading">加载中...</div>
  </div>
  ```
  ```ts
  app.mount("#app");
  document.getElementById("loading")?.remove();
  ```
- 配置监控上报：
  使用阿里 Sentry、Fundebug、腾讯 Tlog 等 SDK 上报错误日志。

## 如何实现权限控制

### 路由权限控制

#### 1.1 权限设计思路

- 后端返回用户角色/权限码
- 前端动态生成路由(`addRoute`或`filter`)
- 使用 Vue Router 导航守卫控制访问权限

#### 1.2 实现步骤

##### 一、权限码设计

```ts
// src/types/permission.ts

/** 权限码类型 */
export type PermissionCode =
  | "dashboard:view"
  | "user:edit"
  | "user:delete"
  | "settings:view"
  | "admin:access";

/** 用户权限结构 */
export interface UserPermission {
  roles: string[];
  permissions: PermissionCode[];
}
// src/store/user.ts (Pinia 示例)
import { defineStore } from "pinia";
import type { UserPermission } from "@/types/permission";

export const useUserStore = defineStore("user", {
  state: (): UserPermission => ({
    roles: [],
    permissions: [],
  }),
  actions: {
    setPermissions(perms: string[]) {
      this.permissions = perms as any;
    },
  },
});
```

##### 二、 路由配置中标记权限码

```ts
// src/router/index.ts
import { createRouter, createWebHistory } from "vue-router";
import { useUserStore } from "@/store/user";
// 后端返回权限菜单结构
const routes = [
  {
    path: "/dashboard",
    component: () => import("@/views/Dashboard.vue"),
    meta: { permission: "dashboard:view" },
  },
  {
    path: "/admin",
    component: () => import("@/views/Admin.vue"),
    meta: { permission: "admin:access" },
  },
];
// 递归过滤无权限路由
function filterRoutes(routes, userPerms) {
  return routes.filter((route) => {
    const perm = route.meta?.permission;
    if (perm && !userPerms.includes(perm)) return false;
    if (route.children) {
      route.children = filterRoutes(route.children, userPerms);
    }
    return true;
  });
}
// 新建路由
const router = createRouter({
  history: createWebHistory(),
  routes,
});
//  全局路由守卫实现权限教校验
router.beforeEach((to, _from, next) => {
  const userStore = useUserStore();
  const permission = to.meta?.permission as string | undefined;

  if (permission && !userStore.permissions.includes(permission as any)) {
    next("/403");
  } else {
    next();
  }
});

export default router;
```

### 按钮/组件权限控制

#### 2.1 自定义指令(v-permission)实现 DOM 层级控制

```ts
// src/directives/v-permission.ts
import type { Directive } from "vue";
import { useUserStore } from "@/store/user";

const permissionDirective: Directive = {
  mounted(el, binding) {
    const userStore = useUserStore();
    const required: string = binding.value;
    const hasPermission = userStore.permissions.includes(required as any);
    if (!hasPermission) {
      el.remove();
    }
  },
};

export default permissionDirective;
// main.ts
import permissionDirective from "@/directives/v-permission";
app.directive("permission", permissionDirective);
```

```vue
<!-- 使用 -->
<el-button v-permission="'user:edit'">编辑用户</el-button>
```

#### 2.2 使用组件封装权限判断逻辑

```ts
// src/components/Permission.tsx
import { defineComponent, computed, Slot } from "vue";
import { useUserStore } from "@/store/user";
import type { PermissionCode } from "@/types/permission";

export default defineComponent({
  name: "Permission",
  props: {
    value: { type: String as () => PermissionCode, required: true },
  },
  setup(props, { slots }) {
    const userStore = useUserStore();
    const hasPermission = computed(() =>
      userStore.permissions.includes(props.value),
    );
    return () => (hasPermission.value ? slots.default?.() : null);
  },
});
```

```vue
<!-- 使用 -->
<Permission value="user:edit">
  <el-button>编辑</el-button>
</Permission>
```

#### 2.3 辅助工具函数

```ts
// src/utils/permission.ts
import { useUserStore } from "@/store/user";
import type { PermissionCode } from "@/types/permission";

export function hasPermission(code: PermissionCode): boolean {
  const userStore = useUserStore();
  return userStore.permissions.includes(code);
}
// 使用场景示例
if (hasPermission("user:edit")) {
  // 展示编辑按钮
}
```

### 扩展问题

#### 权限模型设计

1. RBAC 基础模型

- 用户（User）拥有多个角色（Role）
- 每个角色拥有多个权限（Permission）
- 权限可以对应功能点、菜单、接口等

```ts
interface User {
  id: number;
  name: string;
  roles: string[]; // ['admin', 'editor']
}

interface Role {
  name: string;
  permissions: string[]; // ['user:add', 'user:delete']
}
```

2. RBAC vs ABAC
   | 模型 | 特点 |
   | ----------- | ----------- |
   | RBAC | 通过“角色”统一管理权限，维护简单|
   | ABAC | 基于属性控制权限，灵活性更强，但更复杂|

#### 前后端权限如何协作

1. 后端返回权限集合
   - 登陆后,后端返回当前用户的 permissions 列表或 menus 列表
   - 前端根据后端返回构建路由、菜单、组件权限
2. 接口权限校验
   - 前端控制 UI 显示
   - 后端必须校验接口权限->避免“越权调用”
3. 接口权限错误处理
   - 后端返回状态码如 404、200
   - 前端统一处理,如提示无权限、跳转无权限页面

#### 如何入理前端刷新后权限丢失

- 将权限信息换存在 Pinia 和 localStorage/sessionStoroage
- 项目启动时自动从缓存回复权限并动态注册路由

```ts
// 登录成功后
localStorage.setItem("PERMISSIONS", JSON.stringify(userPermissions));

// 页面刷新后
const storedPermissions = JSON.parse(
  localStorage.getItem("PERMISSIONS") || "[]",
);
setupPermissionRoutes(storedPermissions);
```

#### 如何处理无权限界面和 404

```ts
// 定义常驻路由
const constantRoutes: RouteRecordRaw[] = [
  { path: "/login", component: LoginView },
  { path: "/403", component: ForbiddenView },
  { path: "/:pathMatch(.*)*", name: "NotFound", component: NotFoundView },
];

// 路由守卫中判断是否有权限访问
router.beforeEach((to, from, next) => {
  const required = to.meta?.permission;
  const hasPerm = required ? permissionList.includes(required) : true;
  if (!hasPerm) return next("/403");
  next();
});
// 预定义 /403、/404 页面，统一异常路由管理，提高 UX
//  /403.vue: 提示“无权限访问”，可配“返回首页”按钮
// /404.vue: 美观的“页面不存在”提示，适配 SEO 与用户体验
```

## Composition API 如何做逻辑复用和抽象？

### 一、核心思想：函数式组合（Function Composition）

> Composition API 通过将逻辑封装为 **可复用的函数（composable）**，实现更清晰、模块化的逻辑组织方式。

传统 Options API 会将一个功能分散在 `data`、`methods`、`computed` 中，难以维护。而 Composition API 可以将某一功能（如表单处理、弹窗控制、WebSocket 管理）**聚合在一个独立函数中**。

### 二、常见复用逻辑封装类型

| 类型         | 示例                            |
| ------------ | ------------------------------- |
| 状态逻辑     | `useToggle`、`useCounter`       |
| 网络请求     | `useFetch`、`useUserInfo`       |
| 表单处理     | `useForm`、`useFormRules`       |
| 生命周期控制 | `useScrollListener`、`useTimer` |
| 权限判断     | `usePermission`                 |
| 节流防抖     | `useDebounce`、`useThrottle`    |

### 三、封装步骤

1. **抽离逻辑为函数**：定义 `useXxx()` 函数
2. **使用组合式 API**：使用 `ref`、`reactive`、`computed`、`watch`、`onMounted` 等
3. **返回需要暴露的数据与方法**
4. **在组件 `setup()` 中调用复用逻辑**

### 四、示例：封装一个弹窗控制逻辑

```ts
// useModal.ts
import { ref } from "vue";

export function useModal() {
  const visible = ref(false);
  const open = () => (visible.value = true);
  const close = () => (visible.value = false);
  return { visible, open, close };
}
```

组件中使用：

```ts
import { useModal } from "./useModal";

export default {
  setup() {
    const { visible, open, close } = useModal();
    return { visible, open, close };
  },
};
```

### 五、优势总结

| 优势         | 描述                               |
| ------------ | ---------------------------------- |
| 聚合相关逻辑 | 类似“功能模块”而非“选项块”组织方式 |
| 可独立测试   | 函数式结构更适合写单元测试         |
| 无 this 依赖 | 更清晰、类型安全                   |
| 易于组合     | 可在一个组件中调用多个 composable  |
| 支持 TS 推导 | 类型系统完美兼容                   |

### 🎤 答题思路

> “Composition API 让我可以将某个功能抽象为 composable 函数，比如弹窗、轮询、表单校验、权限控制等。每个 composable 都是功能独立、可复用、支持类型推导的函数，避免了 mixin 中的命名冲突与来源不清问题，让逻辑组织更加聚合、清晰，并可在多个组件中复用。”

### 你是否封装过复杂 composable？如何组织多个内部 composable？

#### 一、为什么迁移？

| 优势点     | 说明                               |
| ---------- | ---------------------------------- |
| 冷启动更快 | Vite 使用 ESBuild 预构建，秒级启动 |
| 构建更快   | 原生模块化，Rollup 高效打包        |
| 配置更简单 | 默认约定优于配置                   |
| 热更新快   | 模块级更新，无需整包替换           |

#### 二、核心配置迁移对照表

| 功能         | Webpack 配置                  | Vite 替代方式                        |
| ------------ | ----------------------------- | ------------------------------------ |
| 入口文件     | `entry: './src/main.js'`      | 默认使用 `index.html` 引入入口       |
| 别名 alias   | `resolve.alias`               | `resolve.alias`（相同）              |
| 环境变量     | `.env / process.env`          | `.env` + `import.meta.env`           |
| 静态资源     | `file-loader` / `url-loader`  | Vite 内置支持，无需额外 loader       |
| 热更新       | HMR 插件                      | Vite 默认支持                        |
| Babel 编译   | `babel-loader` + plugins      | Vite 使用 esbuild 替代（可选 Babel） |
| CSS 预处理器 | `sass-loader` / `less-loader` | Vite 自动识别对应依赖                |
| 插件系统     | Webpack plugins               | Vite plugins（基于 Rollup）          |
| 构建拆包     | `optimization.splitChunks`    | `rollupOptions.output.manualChunks`  |

#### 三、常见兼容性问题及解决方案

##### ✅ 1. CommonJS 模块不兼容（如 `require()`）

- **问题：** Vite 是原生 ESM 模块，不支持 CommonJS 动态导入
- **解决方案：**
  - 升级第三方包为 ESM 版本（或使用 vite-plugin-commonjs）
  - 使用 `import()` 替代 `require()`

##### ✅ 2. 全局变量问题（如 `process`, `__dirname`）

- **问题：** Vite 在浏览器环境中运行，无 Node 全局变量
- **解决方案：**
  - 配置 `define`:
    ```ts
    define: {
      'process.env': {}
    }
    ```
  - 或使用 polyfill 插件如 `vite-plugin-node-polyfills`

##### ✅ 3. HTML 模板不再用 HtmlWebpackPlugin

- Vite 直接使用 `index.html`，支持 EJS 模板语法
- 替代 `<%= BASE_URL %>` 等语法为 `import.meta.env.BASE_URL`

##### ✅ 4. 第三方 UI 库兼容性（如 ElementUI、iView）

- Vue2 项目需迁移到 Vue3（因为 Vite 默认支持 Vue3）
- Vue2 可使用 `vite-plugin-vue2` 支持旧项目（需额外配置）

#### 四、Vite 构建配置推荐（vite.config.ts）

```ts
import { defineConfig } from "vite";
import vue from "@vitejs/plugin-vue";

export default defineConfig({
  plugins: [vue()],
  resolve: {
    alias: {
      "@": "/src",
    },
  },
  build: {
    rollupOptions: {
      output: {
        manualChunks: {
          vendor: ["vue", "vue-router"],
        },
      },
    },
  },
  define: {
    "process.env": {},
  },
});
```

#### 答题思路

```txt
 “在将 Webpack 项目迁移到 Vite 的过程中，我梳理了 alias、loader、plugin 等配置差异，并对静态资源、环境变量和构建优化做了适配。迁移中遇到最大的兼容问题是一些使用 CommonJS 的老库，我通过替换为 ESM 或配置插件解决。最终实现了启动速度提升 5 倍，构建时间缩短约 50%，热更新体验更流畅。”
```

## Composition API 相比 Options API 有哪些优势？

1. 逻辑聚合更清晰、更易于维护
   - 引入了`setup()`,可按功能组合代码(比如将表单逻辑集中在一个 `composable` 函数中)
   - 更适合大型项目的模块化
2. 响应式系统更灵活
   - `Composition API` 使用 `Vue3` 新的响应式系统（基于 `Proxy）`，,搭配 `ref` 和 `reactive` 能实现更精准的响应控制。
   - 可按需使用响应式变量，不再局限于 `data` 对象
   - 可以创建响应式函数和模块（如 `composable` `hooks`）
   - 支持逻辑抽离，不依赖 `this`
3. 生命周期更灵活,可重用性更强
   - `Vue3` 生命周期函数（如 `onMounted`, `onUnmounted`）可以在任何自定义函数中使用，支持复用逻辑中注册生命周期
4. 支持逻辑复用的函数式设计
   - `Composition API` 支持通过“composable”封装业务逻辑（如 useForm, useFetch），实现高度复用和测试友好
5. 更好的支持 TypeScript
   - `Composition API` 在类型推导、IDE 支持方面比 `Options API` 更友好

### 答题话术

```txt
 “`Composition API` 更适合组织复杂组件逻辑，通过函数式组合实现代码聚合、逻辑复用，更利于维护和测试。同时搭配
`Proxy` 响应系统与生命周期函数，可以让逻辑抽离到 composable 中，是真正面向模块化和大型应用的 API 设计。”
```

## 自定义指令封装方案

封装方式建议统一写在 `/directives/index.ts` 中并在 `main.ts` 注册。

### 常见指令创建

#### 1. 权限控制指令（`v-permission`）

```js
// directives/permission.ts
export default {
  mounted(el, binding) {
    const roles = getUserRoles();
    if (!roles.includes(binding.value)) {
      el.parentNode?.removeChild(el);
    }
  },
};
```

```ts
// main.ts
import permission from "./directives/permission";

app.directive("permission", permission);
```

使用方式：

```html
<!-- 只有 admin 能看到按钮 -->
<button v-permission="'admin'">删除</button>
```

---

#### 2. 图片懒加载指令（`v-lazy`）

```ts
export default {
  mounted(el, binding) {
    const observer = new IntersectionObserver(([entry]) => {
      if (entry.isIntersecting) {
        el.src = binding.value;
        observer.unobserve(el);
      }
    });
    observer.observe(el);
  },
};
```

```html
<img v-lazy="imgUrl" alt="懒加载图片" />
```

#### 3. 自动聚焦（`v-focus`）

```ts
export default {
  mounted(el) {
    el.focus();
  },
};
```

```html
<input v-focus />
```

##### 指令注册

```ts
// directives/index.ts
import permission from "./permission";
import lazy from "./lazy";
import focus from "./focus";

const directives = {
  permission,
  lazy,
  focus,
};

export default {
  install(app) {
    Object.keys(directives).forEach((key) => {
      app.directive(key, directives[key]);
    });
  },
};
```

```ts
// main.ts
import Directives from "./directives";
app.use(Directives);
```

## Vue2 中 $set 和 Vue3 的 reactive 区别是什么？

| 特性           | Vue2 (Vue.set)                                 | Vue3 (reactive)                            |
| -------------- | ---------------------------------------------- | ------------------------------------------ |
| 响应式核心原理 | Object.defineProperty 劫持属性                 | Proxy 代理整个对象                         |
| 新增属性响应式 | 需要使用 Vue.set(target, key, value)           | reactive 创建后自动响应，支持新增/删除属性 |
| 数组响应问题   | 无法监听通过索引直接设置的值、不能检测长度变化 | 完整支持索引变化和 length 响应式           |
| 支持的数据类型 | 仅对象和数组                                   | 支持对象、数组、Map、Set 等                |

## 生命周期中你会在哪个阶段发起接口请求？为什么？

### Vue2：

> **通常在 created 或 mounted 中发起接口请求。**

- created：组件已创建，可访问 data 和方法，适合早期请求（不依赖 DOM）。

- mounted：DOM 已挂载，适合依赖 DOM 或初始渲染完成后请求。

**推荐使用：**

- created 阶段发起初始化数据加载请求，性能更优。

- 若需要依赖 DOM，比如初始化图表，可在 mounted 发起请求。

### Vue3（组合式 API）：

> 在 `setup()` 中不建议直接请求数据，而是使用 `onMounted()` 或 `onBeforeMount()` 生命周期钩子来处理异步逻辑。

```vue
import { onMounted } from 'vue'; onMounted(() => { fetchData(); });
```

## setup 执行时有哪些生命周期已经发生？不能访问哪些属性？

**setup 执行时：**

- 生命周期钩子尚未执行（如 onMounted、onCreated 等），setup 是在组件创建阶段调用。
- 此时：
  - 可以访问：props、context、emit、ref、reactive、computed 等组合式 API。
  - 不能访问：this（没有上下文）、组件实例、DOM 元素等。

**setup 中的注意事项：**

- setup 是组合式 API 的入口。
- 不存在 this 上下文，应使用 ref 和 reactive 替代。
- 若需要响应式生命周期钩子，使用 onMounted、onBeforeMount、onUnmounted 等组合 API。

```ts
export default {
  setup(props, { emit }) {
    const count = ref(0);

    onMounted(() => {
      console.log("组件已挂载");
    });

    return {
      count,
    };
  },
};
```

## Vue 项目中如何做模块拆分

### Vuex

#### 1. 基本结构：

```ts
// store/modules/user.js
export default {
  namespaced: true, // 避免命名冲突
  state: () => ({
    name: "",
    token: "",
  }),
  mutations: {
    setToken(state, token) {
      state.token = token;
    },
  },
  actions: {
    login({ commit }, payload) {
      // 异步操作
      commit("setToken", payload.token);
    },
  },
};
```

#### 注册模块

```ts
// store/index.js
import Vue from "vue";
import Vuex from "vuex";
import user from "./modules/user";

Vue.use(Vuex);

export default new Vuex.Store({
  modules: {
    user,
  },
});
```

#### 3. 组件中访问

```ts
this.$store.dispatch("user/login", { token: "abc" });
this.$store.state.user.token;
```

### Pinia

#### 1. 每个模块一个单独的 Store 文件

```ts
// stores/user.ts
import { defineStore } from "pinia";

export const useUserStore = defineStore("user", {
  state: () => ({
    name: "",
    token: "",
  }),
  getters: {
    isLoggedIn: (state) => !!state.token,
  },
  actions: {
    login(payload: { token: string }) {
      this.token = payload.token;
    },
    logout() {
      this.token = "";
    },
  },
});
```

#### 2. 全局注册 Pinia

```ts
// main.ts
import { createApp } from "vue";
import { createPinia } from "pinia";
import App from "./App.vue";

const app = createApp(App);
app.use(createPinia());
app.mount("#app");
```

#### 3. 在组件中使用

```ts
import { useUserStore } from "@/stores/user";

const userStore = useUserStore();
userStore.login({ token: "abc" });
console.log(userStore.token);
```

## Vue Router 路由传参 params 和 query 的区别

### 区别

| 对比项         | params                           | query                          |
| -------------- | -------------------------------- | ------------------------------ |
| 是否要定义路径 | 需要定义 :param                  | ❌ 不需要                      |
| 路由使用方式   | name + params                    | path + query                   |
| URL 形式       | user/123                         | user?id=123                    |
| SEO 友好       | ✅ 更友好                        | ❌ 略差                        |
| 刷新保留       | ✅ （仅在 name + params 情况下） | 保留                           |
| 多参数适用性   | 适用于主要标识、ID 类参数        | 适用于分页、筛选、搜索等可选项 |

### 🎤 答题思路

> Vue Router 中的 `params` 通常用于**必须出现的路径参数**，如资源 ID，能提供更好的 SEO 表现；而 `query` 用于**可选参数或搜索筛选类需求**，配置更灵活。注意使用 `params` 时**要配合命名路由，否则刷新会丢失参数**。
