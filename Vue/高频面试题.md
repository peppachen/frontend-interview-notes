## Vue vs React 对比

> 1. 基于原生 ES Module：
>    Vite 利用浏览器原生支持的 ES Module 加载机制进行开发，无需像 Webpack 一样打包整个项目，因此在开发模式下启动非常迅速。
> 2. 依赖预构建（Pre-bundling）：
>    Vite 会使用 esbuild 对依赖进行预构建，提高冷启动速度。比如我们在项目中首次构建时间从 20s 降到了 5s
> 3. 模块热更新（HMR）：
>    Vite 通过内嵌缓存机制和按需更新的方式，只重新加载被修改的模块，大大提升了开发时的热更新效率。
> 4. 构建优化：
>    在生产构建中，Vite 底层使用 Rollup，我在项目中通过配置 SplitChunks、按需加载、Tree-shaking 等手段，最终将首屏资源体积压缩了 35%，并把构建时间从 12s 降到了 9s。
>    同时配置了 define 全局变量、alias 路径别名、动态导入（import()）等优化方式。

### 一、核心对比表格

| 维度           | Vue（特别是 Vue3）                                  | React（特别是 Hooks/Fiber 架构） |
| -------------- | --------------------------------------------------- | -------------------------------- |
| **设计理念**   | 渐进式框架（MVVM）                                  | 纯视图层库（函数式组件）         |
| **语法结构**   | Options API / Composition API                       | Function Component + Hooks       |
| **模板语法**   | HTML 模板 + 指令（v-if、v-for）                     | JSX（JavaScript XML）            |
| **响应式原理** | Vue2: `Object.defineProperty`<br>Vue3: `Proxy`      | `setState` + immutable 数据流    |
| **状态管理**   | Vuex / Pinia                                        | Redux / Context                  |
| **组件通信**   | props / emits / provide-inject                      | props / Context / Redux          |
| **生命周期**   | created / mounted / updated 等<br>Vue3: `onMounted` | useEffect / useLayoutEffect      |
| **Diff 算法**  | 双端对比 + key + LIS + patchFlag                    | Fiber 架构链表遍历 + 优先级调度  |
| **性能优化**   | 编译时静态提升 / patchFlag 动态标记                 | memo / useCallback / useMemo     |
| **SSR 支持**   | Nuxt.js                                             | Next.js                          |
| **构建工具**   | Vue CLI / Vite                                      | CRA / Vite / Webpack             |
| **生态**       | 官方统一工具链完善                                  | 社区丰富，第三方生态强           |
| **学习曲线**   | 模板语法易上手                                      | 逻辑更灵活，工程化更强           |
| **典型场景**   | 中后台系统 / 大型表单 / CMS                         | WebApp / 跨平台（React Native）  |

### 二、总结话术

> Vue 更适合强调开发效率和响应式交互的项目，Composition API 提升了逻辑复用性；React 更倾向自由组合的函数式架构，Fiber 架构实现了可中断调度机制，更适合构建复杂交互和高并发场景。二者各有优势，应结合业务需求选择。

## Vue3 和 Vue2 的核心区别？

> 答题模板
> Vue3 在保持 Vue2 响应式编程理念的同时，引入了 Composition API 和 Proxy 新架构，大幅提升了组件逻辑复用性和性能表现。同时对 TypeScript 支持更完善，打包更小，启动更快，适合大型项目开发。对比 Vue2 的 Options API，Vue3 更具现代化、模块化的架构设计。

1. 响应式系统实现不同

- `vue2` 使用 `object.defineProerty`,只能劫持已有属性,需手动深度监听(如数组)
- `vue3` 使用 `proxy` 可动态拦截属性添加删除,支持深层次嵌套结构,解决了 Vue2 中属性新增/删除监听不到的问题

2. 新增 Compostion API (组合式 API)

   - `vue2`使用 data(),methods,computed,wathch 等分散配置
   - `vue3`引入 seetup()函数,允许将相关逻辑聚合组织;更易于逻辑复用

3. 生命周期变化
   | Vue2 | vue3 |
   | - | -- |
   | created | setup() |
   | moutend | onMoutend() |
   | beforeDestroy | onBeforeUnmount() |
4. 模板编译和指令处理变化

   - v-if 和 v-for 优先级不同
     - `vue2`:v-for 优先于 v-if
     - `vue3 `:v-if 优先,避免无意义的循环
   - 新增〈script setup>语法糖,减少模板代码冗余

5. 性能优化
   - 默认支持`Tree-shaking`,体积更小
   - 更快的渲染机制(compiler 优化+Proxy)
   - 更好的 TypeScript 支持

> **答题话术**
> “Vue3 的最大变化在于底层响应式由 Object.defineProperty 改为 Proxy，解决了 Vue2 中属性新增/删除-监听不到的问题。同时，它引入了 Composition API，将逻辑更集中管理，更利于复用与类型推导。生命周期也发生变化，统一在 setup() 中调用 onMounted 等函数。我在项目中已经完成从 Vue2 向 Vue3 的升级，整体代码维护性和性能都有显著提升。”

### setup()中为什么不能使用 this?

- `setup()`在整个生命周期中优先级最高,在**组件实例创建之前执行的**，此时组件实例（即 this）尚未被完全初始化;
- `setup()`用于逻辑组织和组合的函数,所有的数据、props、methods 都通过函数参数解构或返回值暴露，**不再依赖 this 上的绑定**。

> **答题话术**
> “因为 setup() 是在组件实例创建之前执行的，因此此时还没有 this 可用。Vue3 推崇函数式逻辑组合方式，因此不再依赖 this，而是通过参数解构和返回对象来使用 props、emit 和响应式数据。这也是 Composition API 更具逻辑复用性和类型推导优势的重要体现。

## Vue2 和 Vue3 响应式的区别

### Vue2(object.defineProerty)

- 遍历递归对象,对每个属性单独设置` getter``setter `,性能开销较大;
- **无法动态监听属性变化(增删)**,对象属性变化时不会触发视图更新，需通过 `Vue.set` 或 `Vue.delete` **手动处理**;
- 无法直接监听数组索引的修改（如 `arr[0] = 1` ）和 `length` 变化;
- 只能支持代理普通对象和数组,不支持 `Map`、`Set` 等复杂数据结构。

### Vue3(Proxy)

- `Proxy` 可以直接代理整个对象，因此可以监听属性的**动态增删**，不再需要手动操作。
- 能够直接监听数组索引的修改（如 `arr[0] = 1` ）以及 `length` 变化。
- 采用懒代理模式,只有在访问属性时才会递归代理子对象,避免了递归遍历的性能开销。
- 支持更多数据结构,除了普通对象数组,`Proxy`还可以代理 `Map`、`Set` 等复杂数据结构。

## Vue2 升级 Vue3 如何实现?遇到的问题,如何解决?

Vue3 在性能、响应式系统、TS 支持、逻辑复用等方面较 Vue2 有显著提升，因此希望在不影响业务交付的前提下，将项目平滑迁移到 Vue3。

### 二、升级整体流程（渐进式迁移策略）

1. **依赖升级**

   - 升级 Vue2 → Vue3 (`vue@next`)
   - 升级 Vue Router（v3 → v4）、Vuex（或替换为 Pinia）

2. **构建工具改造**

   - Webpack → Vite
   - 替换 vue-loader、配置支持 `<script setup>`、TS 模块

3. **逐步重构组件**

   - 选取低风险模块做试点
   - 逐步将 Options API 重构为 Composition API

4. **重写 mixins / 插件**
   - 将 mixin 改写为 composable 函数
   - 用 props 和 emit 替代 this

---

### 三、常见问题与解决方案

| 问题类型            | 描述                                | 解决方案                                   |
| ------------------- | ----------------------------------- | ------------------------------------------ |
| 生命周期变化        | `beforeDestroy` → `onBeforeUnmount` | 使用组合式生命周期 API                     |
| `this` 失效         | setup() 中 `this` 为 undefined      | 用 `setup(props, { emit })` 替代访问方式   |
| 第三方库不兼容      | 如 ElementUI 不支持 Vue3            | 替换为 Element Plus / Naive UI             |
| `$listeners/$attrs` | 属性合并行为变化                    | 审查透传逻辑，适配 Vue3 的新继承机制       |
| 全局 API 变化       | Vue2 的 `Vue.use()` 等方法          | 替换为 `createApp().use()`                 |
| TS 类型变化         | 类型声明方式不同                    | 使用 `defineComponent` + `withDefaults` 等 |

### 四、优化方案

- 使用官方兼容包：[@vue/compat](https://github.com/vuejs/vue-compat)
- 编写单元测试确保迁移后功能一致
- 每次迁移拆解为小任务，利于回滚
- 重构逻辑同步更新团队协作方式与代码规范

### 五、答题话术

> “我参与了公司后台系统从 Vue2 到 Vue3 的升级，采用渐进式迁移策略。首先升级了核心依赖和构建工具，将 Webpack 替换为 Vite，并用 `defineComponent + setup` 改写核心模块逻辑。过程中遇到最大的问题是一些 mixin 无法直接替换为 hooks，我将其重构为 composable，并通过单元测试确保功能一致性。最终项目构建速度提升了 40%，逻辑更清晰，维护成本也降低了。”

#### 生命周期发生变化迁移优化策略

##### 一、生命周期对照表

| Vue2 生命周期 | Vue3 替代 API     | 执行阶段            |
| ------------- | ----------------- | ------------------- |
| beforeCreate  | —（合并进 setup） | 组件实例初始化前    |
| created       | —（合并进 setup） | 组件创建后          |
| beforeMount   | onBeforeMount     | DOM 挂载前          |
| mounted       | onMounted         | DOM 挂载后          |
| beforeUpdate  | onBeforeUpdate    | 更新前              |
| updated       | onUpdated         | 更新后              |
| beforeDestroy | onBeforeUnmount   | 卸载前              |
| destroyed     | onUnmounted       | 卸载后              |
| activated     | onActivated       | `<keep-alive>` 激活 |
| deactivated   | onDeactivated     | `<keep-alive>` 失活 |

##### 二、组合式 API 替代写法示例

###### ✅ Vue2 示例（Options API）

```js
export default {
  created() {
    this.init();
  },
  mounted() {
    this.fetchData();
  },
  beforeDestroy() {
    this.cleanUp();
  },
};
```

###### ✅ Vue3 示例（Composition API）

```ts
import { onMounted, onUnmounted } from "vue";

export default {
  setup(props, { emit }) {
    const fetchData = () => {
      /* 获取数据 */
    };
    const cleanUp = () => {
      /* 卸载清理 */
    };

    onMounted(() => {
      fetchData();
    });

    onUnmounted(() => {
      cleanUp();
    });

    return {
      /* 暴露组件内容 */
    };
  },
};
```

##### 三、具体迁移解决策略总结

- ✅ **created/beforeCreate → setup() 中初始化逻辑**
  - 这两个钩子合并到 setup() 中，初始化逻辑直接写在顶层。
- ✅ **beforeDestroy/destroyed → onBeforeUnmount/onUnmounted**
  - 可用于解绑事件、清理副作用等。
- ✅ **生命周期调用顺序不变**
  - Vue3 的生命周期钩子只是名称变化，时机本质和 Vue2 一致。
- ✅ **组合式函数中可封装生命周期逻辑**
  - 可以在 composable 中使用生命周期，增强复用性。

```ts
// useWebSocket.ts
export function useWebSocket() {
  onMounted(() => {
    connect();
  });
  onUnmounted(() => {
    disconnect();
  });
}
```

##### 四、答题话术

> “Vue3 生命周期用组合式 API 表达更清晰。原本写在 created 或 mounted 中的初始化逻辑现在直接写在 setup 顶层，卸载相关逻辑用 onUnmounted 替代 beforeDestroy。我在项目中会将常见逻辑封装进 composable，比如 usePolling 或 useWebSocket，使生命周期控制更集中、易复用。”

### 如何处理 Vue2 中的组件通信逻辑？

### Mixin 如何迁移为 Composition API？

#### 一、🌱 为什么要迁移 mixin？

Vue2 中的 mixin 虽然可以实现逻辑复用，但存在以下问题：

| 问题           | 描述                           |
| -------------- | ------------------------------ |
| 命名冲突风险   | 多个 mixin 的方法/变量容易重名 |
| 逻辑来源不清晰 | 方法来自哪里难以追溯           |
| 类型提示缺失   | 对 TypeScript 支持较差         |
| 可测试性弱     | 不易单元测试和复用             |

#### 二、🌟 Vue3 推荐使用 `composable` 替代 mixin

Composition API 提倡逻辑复用通过**函数抽离（composable）**实现。

> Composable 是一个普通的函数，内部使用 `ref`、`computed`、`watch`、生命周期钩子等组合式 API，将逻辑抽象封装。

#### 三、🚀 Mixin → Composable 的迁移步骤

1. **分析 mixin 的内容**

   - `data` → 转为 `ref` 或 `reactive`
   - `methods` → 普通函数
   - `computed` → `computed()`
   - `watch` → `watch()`
   - `生命周期钩子` → `onXXX()`

2. **创建 `useXXX()` 函数**

3. **在组件中使用**

#### 四、🧩 示例：从 mixin 到 composable

##### ✅ Vue2 中的 mixin：

```js
// loggerMixin.js
export default {
  data() {
    return { logCount: 0 };
  },
  methods: {
    log(msg) {
      this.logCount++;
      console.log(`[${this.logCount}] ${msg}`);
    },
  },
  mounted() {
    this.log("组件已挂载");
  },
};
```

##### ✅ Vue3 中的 composable：

```ts
// useLogger.ts
import { ref, onMounted } from "vue";

export function useLogger() {
  const logCount = ref(0);
  const log = (msg: string) => {
    logCount.value++;
    console.log(`[${logCount.value}] ${msg}`);
  };

  onMounted(() => {
    log("组件已挂载");
  });

  return { log, logCount };
}
```

##### ✅ 组件中使用：

```ts
import { useLogger } from "./useLogger";

export default {
  setup() {
    const { log } = useLogger();
    log("手动调用日志");

    return {};
  },
};
```

#### 五、🗣️ 面试话术模板

> “Vue3 中我会将 Vue2 的 mixin 逻辑迁移为 `composable` 函数，比如把日志记录逻辑抽象为 `useLogger`，用 `ref` 替代 data，函数内部使用生命周期钩子，比如 `onMounted`。这样做的好处是逻辑来源明确、命名冲突避免，并且可以独立测试和复用，在团队项目中效果非常好。”

### composable 和 mixin 的异同（Vue 面试常考）

#### 一、🌱 相同点

| 相同点             | 描述                                                   |
| ------------------ | ------------------------------------------------------ |
| 逻辑复用           | 都用于复用组件间的逻辑，比如轮询、事件监听、数据同步等 |
| 可在多个组件中使用 | 可跨组件共享功能                                       |
| 可以访问生命周期   | 都可以访问生命周期钩子控制逻辑时机                     |

---

#### 二、🚧 不同点对比

| 维度           | mixin（Vue2）                             | composable（Vue3）                           |
| -------------- | ----------------------------------------- | -------------------------------------------- |
| 本质           | 一个对象（包含 data/methods/computed 等） | 一个函数（返回响应式对象或函数）             |
| 使用方式       | 通过 `mixins: [xxMixin]` 注入             | 在 `setup()` 中直接调用：`useXxx()`          |
| 命名冲突       | 容易冲突（多个 mixin 合并到 this）        | 不会冲突（作用域封闭、变量自定义）           |
| 逻辑来源清晰度 | 差（方法来自哪个 mixin 不清楚）           | 清晰（从哪个 `useXXX()` 函数引入一目了然）   |
| 类型支持       | 差，TS 推导困难                           | 好，组合式 API 完全支持 TypeScript           |
| 调试能力       | 弱（this 上挂载很多不可见字段）           | 强（每个 composable 可独立调试、单元测试）   |
| 生命周期使用   | 写在组件中                                | 可在函数中使用生命周期钩子（如 `onMounted`） |
| 可测试性       | 差（全局混入不易单测）                    | 好（函数可单元测试、Mock、复用）             |

#### 三、🗣️ 面试话术模板

> “Mixin 是 Vue2 中常见的逻辑复用手段，但在实践中容易出现命名冲突、来源不明、类型难推导等问题。而 Vue3 的 composable 是基于 Composition API 的函数抽象方式，支持封装逻辑并返回响应式数据，不仅逻辑聚合清晰、变量作用域隔离，而且对 TypeScript 更友好，也方便测试和调试。在项目中我已经将常用 mixin 全部重构为 composable 函数，例如 usePolling、useLogger、useForm 等。”

### 如何保障升级过程中的线上稳定性？

#### 一、🧭 升级策略：渐进式迁移

- 拆分模块，优先升级非核心、非高流量页面
- 使用官方的兼容包 `@vue/compat` 实现 Vue2/3 混合运行
- 支持 Vue2 与 Vue3 并存（如 monorepo 或微前端架构）
- 分阶段替换组件与逻辑，逐步稳定替换关键路径

#### 二、🧪 自动化测试保障

| 类型     | 目标                                   |
| -------- | -------------------------------------- |
| 单元测试 | 保证核心逻辑函数和 composable 正确执行 |
| 组件测试 | 校验 props、事件、UI 行为是否一致      |
| E2E 测试 | 验证完整业务流程（如 登录 → 下单）     |

- 对升级模块补全测试覆盖率
- 升级前后运行测试集，确保功能无回归

#### 三、🔍 比对机制与双产线校验

- 新旧页面并存（如 /page-vue2 与 /page-vue3）
- 埋点监控或行为统计对比页面数据差异
- 可采用“影子发布”方式，业务无感知下测试 Vue3 页面表现

#### 四、📡 日志与监控体系

- 接入前端错误监控工具（如 Sentry）
- 接入性能埋点（如 FCP、LCP、JS 错误、白屏率等）
- Vue3 页面异常统一上报：白屏、网络异常、组件渲染失败等

#### 五、🧯 回滚策略与灰度发布

- 每次构建记录版本快照，支持快速版本回滚
- 灰度策略控制升级用户比例，逐步扩大范围
- 高优先级页面上线前先内测 / 小流量用户使用

#### 🎤 面试话术模板

> “在 Vue2 升级 Vue3 的过程中，我采用渐进式迁移方式，通过功能分包、双版本共存、可控灰度上线，保障升级风险。配合单元测试与 E2E 用例回归，确保功能一致性。我们还接入了 Sentry 做前端异常监控，并设置了版本快照回滚策略，一旦发现问题可在 5 分钟内切回旧版本，有效降低了升级风险。”

## 为什么 Vue2 的数组变更方法不能被监听？如何解决？

## v-show 和 v-if 的区别

- **渲染方式：**
  💡v-if：条件为 true 时才会渲染元素，条件为 false 时销毁元素。
  💡v-show：始终渲染元素，只是通过 CSS 控制 `display 属性`来显示或隐藏。
- **适用场景：**
  💡v-if：适用于条件变化不频繁的场景。
  💡v-show：适用于条件变化频繁的场景。

## 为何 v-if 和 v-for 不能一起使用？

`v-if` 和 `v-for` 不能直接一起使用的原因，主要是因为它们在 **解析优先级** 和 **逻辑处理** 上存在冲突。

由于`v-for` 的解析优先级高于 `v-if`，同时使用 v-if 和 v-for，Vue 首先会循环创建所有 dom 元素，然后根据条件来判断是否渲染每个元素，这种方式可能导致 Vue 进行大量的 DOM 操作，性能较差。其次，`v-for` 会为每个循环项创建一个新的作用域，而 `v-if` 的条件如果依赖于这个作用域内的数据，可能导致判断逻辑异常。

为避免上述问题，vue 官方推荐我们将 `v-if` 放到 `v-for` 外层，或者将 `v-if` 放置到 `v-for` 内部的单个节点上。

```js
<div v-if="show">
  <div v-for="item in list" :key="item.id">{{ item.name }}</div>
</div>
```

## computed 和 watch 有什么区别

**computed**用于计算基于响应式数据的值，并缓存结果:

```vue
<template>
  <div>
    <p>原始值：{{ count }}</p>
    <p>计算后的数值：{{ doubledCount }}</p>
  </div>
</template>

<script setup>
import { ref, computed } from "vue";

const count = ref(2);

// 计算属性
const doubledCount = computed(() => count.value * 2);
</script>
```

**watch**用于监听数据变化并执行副作用操作

```vue
<template>
  <div>
    <p>原始数值：{{ count }}</p>
    <button @click="count++">增加数值</button>
  </div>
</template>

<script setup>
import { ref, watch } from "vue";

const count = ref(0);

// 监听器
watch(
  count,
  (newVal, oldVal) => {
    console.log(`数值从 ${oldVal} 变为 ${newVal}`);
  },
  // 立即生效immdiate
  //深度监听deep
);
</script>
```

| 特性 | `computed` | `watch` |
| | | -- |
| **用途** | 用于计算基于响应式数据的值，并缓存结果 | 用于监听数据变化并执行副作用操作 |
| **返回值** | 返回计算结果 | 不返回值，执行副作用 |
| **缓存机制** | 只有在访问时才会计算，会缓存计算结果，仅当依赖变化时重新计算 | 数据变化时立即执行回调，不缓存，每次数据变化都会触发回调 |
| **适用场景** | 计算派生数据，避免不必要的重复计算 | 执行异步操作、处理副作用操作，如 API 请求 |
| **性能** | 性能较好，避免重复计算 | 每次数据变化时都会执行回调函数 |

## watch 和 watchEffect 的区别

### 依赖追踪方式

`watch` ：需要**显式声明依赖，**监听指定的数据源\*\*；可以监听多个数据源或进行深度监听。

```js
import { watch, reactive } from "vue";
const state = reactive({
  count: 0,
});
watch(
  () => state.count, // 显式声明监听的依赖
  (newCount, oldCount) => {
    console.log(`新值 ${newCount} 老值 ${oldCount}`);
  },
);
```

`watchEffect` ：会自动追踪 **作用域内所有的响应式依赖**，不需要显式声明依赖。

```js
import { watchEffect, reactive } from "vue";
const state = reactive({
  count: 0,
});
watchEffect(() => {
  console.log(`Count 变化了: ${state.count}`); // 自动追踪 `state.count`
});
```

### 执行时机

`watch` ：在监听的响应式数据变化后立即执行。

`watchEffect` ：在 **组件挂载时** 执行一次副作用，并在 **依赖发生变化时** 再次执行。

### 适用场景

`watch` ：适用于 **监听特定数据** 变化并执行副作用的场景，如 API 请求、保存操作等。适合需要 **访问新值和旧值** 进行比较的场景。

`watchEffect` ：不需要访问旧值，适用于 **自动追踪多个响应式依赖** 的副作用，如渲染、自动保存等。

## 如何设计一个通用组件？

## Vue 项目打包后白屏可能有哪些原因？

## 如何实现权限控制

## Composition API 如何做逻辑复用和抽象？

### 一、核心思想：函数式组合（Function Composition）

> Composition API 通过将逻辑封装为 **可复用的函数（composable）**，实现更清晰、模块化的逻辑组织方式。

传统 Options API 会将一个功能分散在 `data`、`methods`、`computed` 中，难以维护。而 Composition API 可以将某一功能（如表单处理、弹窗控制、WebSocket 管理）**聚合在一个独立函数中**。

### 二、常见复用逻辑封装类型

| 类型         | 示例                            |
| ------------ | ------------------------------- |
| 状态逻辑     | `useToggle`、`useCounter`       |
| 网络请求     | `useFetch`、`useUserInfo`       |
| 表单处理     | `useForm`、`useFormRules`       |
| 生命周期控制 | `useScrollListener`、`useTimer` |
| 权限判断     | `usePermission`                 |
| 节流防抖     | `useDebounce`、`useThrottle`    |

### 三、封装步骤

1. **抽离逻辑为函数**：定义 `useXxx()` 函数
2. **使用组合式 API**：使用 `ref`、`reactive`、`computed`、`watch`、`onMounted` 等
3. **返回需要暴露的数据与方法**
4. **在组件 `setup()` 中调用复用逻辑**

### 四、示例：封装一个弹窗控制逻辑

```ts
// useModal.ts
import { ref } from "vue";

export function useModal() {
  const visible = ref(false);
  const open = () => (visible.value = true);
  const close = () => (visible.value = false);
  return { visible, open, close };
}
```

组件中使用：

```ts
import { useModal } from "./useModal";

export default {
  setup() {
    const { visible, open, close } = useModal();
    return { visible, open, close };
  },
};
```

### 五、优势总结

| 优势         | 描述                               |
| ------------ | ---------------------------------- |
| 聚合相关逻辑 | 类似“功能模块”而非“选项块”组织方式 |
| 可独立测试   | 函数式结构更适合写单元测试         |
| 无 this 依赖 | 更清晰、类型安全                   |
| 易于组合     | 可在一个组件中调用多个 composable  |
| 支持 TS 推导 | 类型系统完美兼容                   |

### 🎤 面试话术模板（推荐）

> “Composition API 让我可以将某个功能抽象为 composable 函数，比如弹窗、轮询、表单校验、权限控制等。每个 composable 都是功能独立、可复用、支持类型推导的函数，避免了 mixin 中的命名冲突与来源不清问题，让逻辑组织更加聚合、清晰，并可在多个组件中复用。”

### 你是否封装过复杂 composable？如何组织多个内部 composable？

#### 一、为什么迁移？

| 优势点     | 说明                               |
| ---------- | ---------------------------------- |
| 冷启动更快 | Vite 使用 ESBuild 预构建，秒级启动 |
| 构建更快   | 原生模块化，Rollup 高效打包        |
| 配置更简单 | 默认约定优于配置                   |
| 热更新快   | 模块级更新，无需整包替换           |

#### 二、核心配置迁移对照表

| 功能         | Webpack 配置                  | Vite 替代方式                        |
| ------------ | ----------------------------- | ------------------------------------ |
| 入口文件     | `entry: './src/main.js'`      | 默认使用 `index.html` 引入入口       |
| 别名 alias   | `resolve.alias`               | `resolve.alias`（相同）              |
| 环境变量     | `.env / process.env`          | `.env` + `import.meta.env`           |
| 静态资源     | `file-loader` / `url-loader`  | Vite 内置支持，无需额外 loader       |
| 热更新       | HMR 插件                      | Vite 默认支持                        |
| Babel 编译   | `babel-loader` + plugins      | Vite 使用 esbuild 替代（可选 Babel） |
| CSS 预处理器 | `sass-loader` / `less-loader` | Vite 自动识别对应依赖                |
| 插件系统     | Webpack plugins               | Vite plugins（基于 Rollup）          |
| 构建拆包     | `optimization.splitChunks`    | `rollupOptions.output.manualChunks`  |

#### 三、常见兼容性问题及解决方案

##### ✅ 1. CommonJS 模块不兼容（如 `require()`）

- **问题：** Vite 是原生 ESM 模块，不支持 CommonJS 动态导入
- **解决方案：**
  - 升级第三方包为 ESM 版本（或使用 vite-plugin-commonjs）
  - 使用 `import()` 替代 `require()`

##### ✅ 2. 全局变量问题（如 `process`, `__dirname`）

- **问题：** Vite 在浏览器环境中运行，无 Node 全局变量
- **解决方案：**
  - 配置 `define`:
    ```ts
    define: {
      'process.env': {}
    }
    ```
  - 或使用 polyfill 插件如 `vite-plugin-node-polyfills`

##### ✅ 3. HTML 模板不再用 HtmlWebpackPlugin

- Vite 直接使用 `index.html`，支持 EJS 模板语法
- 替代 `<%= BASE_URL %>` 等语法为 `import.meta.env.BASE_URL`

##### ✅ 4. 第三方 UI 库兼容性（如 ElementUI、iView）

- Vue2 项目需迁移到 Vue3（因为 Vite 默认支持 Vue3）
- Vue2 可使用 `vite-plugin-vue2` 支持旧项目（需额外配置）

#### 四、Vite 构建配置推荐（vite.config.ts）

```ts
import { defineConfig } from "vite";
import vue from "@vitejs/plugin-vue";

export default defineConfig({
  plugins: [vue()],
  resolve: {
    alias: {
      "@": "/src",
    },
  },
  build: {
    rollupOptions: {
      output: {
        manualChunks: {
          vendor: ["vue", "vue-router"],
        },
      },
    },
  },
  define: {
    "process.env": {},
  },
});
```

#### 答题话术

> “在将 Webpack 项目迁移到 Vite 的过程中，我梳理了 alias、loader、plugin 等配置差异，并对静态资源、环境变量和构建优化做了适配。迁移中遇到最大的兼容问题是一些使用 CommonJS 的老库，我通过替换为 ESM 或配置插件解决。最终实现了启动速度提升 5 倍，构建时间缩短约 50%，热更新体验更流畅。”

## Composition API 相比 Options API 有哪些优势？

1. 逻辑聚合更清晰、更易于维护
   - 引入了`setup()`,可按功能组合代码(比如将表单逻辑集中在一个 `composable` 函数中)
   - 更适合大型项目的模块化
2. 响应式系统更灵活
   - `Composition API` 使用 `Vue3` 新的响应式系统（基于 `Proxy）`，,搭配 `ref` 和 `reactive` 能实现更精准的响应控制。
   - 可按需使用响应式变量，不再局限于 `data` 对象
   - 可以创建响应式函数和模块（如 `composable` `hooks`）
   - 支持逻辑抽离，不依赖 `this`
3. 生命周期更灵活,可重用性更强
   - `Vue3` 生命周期函数（如 `onMounted`, `onUnmounted`）可以在任何自定义函数中使用，支持复用逻辑中注册生命周期
4. 支持逻辑复用的函数式设计
   - `Composition API` 支持通过“composable”封装业务逻辑（如 useForm, useFetch），实现高度复用和测试友好
5. 更好的支持 TypeScript
   - `Composition API` 在类型推导、IDE 支持方面比 `Options API` 更友好

> **答题话术**
> “`Composition API` 更适合组织复杂组件逻辑，通过函数式组合实现代码聚合、逻辑复用，更利于维护和测试。同时搭配
> `Proxy` 响应系统与生命周期函数，可以让逻辑抽离到 composable 中，是真正面向模块化和大型应用的 API 设计。”
