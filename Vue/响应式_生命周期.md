## 响应式原理

### Vue2

- 使用 Object.defineProperty 实现数据劫持。
- 对每个属性单独递归监听，无法监听新增属性和数组索引变动。
- 对象新增属性需使用 Vue.set 或 this.$set。

```js
Vue.set(obj, "newProp", 123);
this.$set(this.user, "age", 25);
```

#### 数组变异方法监听：

Vue2 通过重写数组原型的变异方法（如 push/pop/splice）实现响应式。

```js
const methodsToPatch = [
  "push",
  "pop",
  "shift",
  "unshift",
  "splice",
  "sort",
  "reverse",
];
```

#### Vue2 无法监听：

- 对象新增属性
- 删除属性（delete obj.key）
- 数组通过索引赋值（arr[0] = 1）

### Vue3

- 使用 Proxy 实现响应式，解决 Vue2 的很多限制。
- 能监听对象属性的新增/删除、数组索引赋值、Map/Set 类型等。

```ts
const state = reactive({ count: 0 });
```

#### Vue3 响应式 API

- reactive(obj)：深层响应式
- ref(value)：响应式基础类型
- toRefs(obj)：将 reactive 对象转换为 ref 结构（适用于解构）
- readonly(obj)：只读代理

## 生命周期对比

### Vue2 生命周期钩子：

```txt
beforeCreate → created → beforeMount → mounted → beforeUpdate → updated → beforeDestroy → destroyed
```

### Vue3 生命周期钩子：

组合式 API 中使用 onXxx 形式的生命周期函数：

```ts
setup() {
onMounted(() => { console.log('组件挂载') })
}
```

| Vue2          | Vue3 (Composition API) |
| ------------- | ---------------------- |
| beforeCreate  | setup()                |
| created       | setup()                |
| beforeMount   | onBeforeMount          |
| mounted       | onMounted              |
| beforeUpdate  | onBeforeUpdate         |
| updated       | onUpdated              |
| beforeDestroy | onBeforeUnmount        |
| destroyed     | onUnmounted            |

## 响应式陷阱 & 对策

### Vue2

- 新增属性不响应：使用 Vue.set
- 数组索引修改不响应：使用 splice

### Vue3

- ref 对象访问属性需 .value
- 解构丢响应式：使用 toRefs
