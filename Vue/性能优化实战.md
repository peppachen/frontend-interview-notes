## 静态内容提升、v-once、v-memo

## 长列表优化：虚拟滚动组件

## 图片懒加载（指令 + IntersectionObserver）

## 异步组件、路由懒加载、首屏优化

## 打包优化：Tree Shaking、按需引入、CDN、缓存策略

## Vite 加载优化方案

### 开发阶段优化（提升热更新速度）

#### 使用 `optimizeDeps` 预构建依赖

```ts
// vite.config.ts
export default defineConfig({
  optimizeDeps: {
    include: ['lodash', 'axios'],
    exclude: ['some-large-lib'],
  },
})

提高首次启动和热更新速度，避免动态依赖分析。
```

#### 排除大型依赖或按需引入

- 使用 `lodash-es + babel-plugin-lodash `实现 `tree-shaking`。
- 使用 `dayjs` 替代 `moment`，减小包体积。

#### 禁用开发环境不必要插件

```ts
plugins: isDev ? [vue()] : [vue(), visualizer()];
```

### 打包阶段优化（构建速度 + 体积压缩）

#### 构建压缩和分包配置

```ts
build: {
minify: 'terser',
terserOptions: {
compress: {
drop_console: true,
drop_debugger: true,
},
},
rollupOptions: {
output: {
manualChunks: {
vue: ['vue', 'vue-router'],
vendor: ['axios', 'lodash-es'],
}
}
}
}
```

#### 使用 CDN 加载第三方库

```ts
import { cdnPlugin } from "vite-plugin-cdn-import";

plugins: [
  cdnPlugin({
    modules: [
      {
        name: "vue",
        var: "Vue",
        path: "https://cdn.jsdelivr.net/npm/vue@3.4.15/dist/vue.global.js",
      },
    ],
  }),
];
```

#### gzip / brotli 压缩资源

```ts
import viteCompression from "vite-plugin-compression";

plugins: [viteCompression({ algorithm: "gzip" })];
```

#### 打包体积分析

```ts
import { visualizer } from "rollup-plugin-visualizer";

plugins: [visualizer({ open: true })];
```

### 运行性能优化（首屏体验）

#### 懒加载路由组件

```ts
const Home = () => import("@/views/Home.vue");
```

#### 图片懒加载与压缩

- 使用 `vite-imagetools` 或手动压缩工具。
- 使用 `IntersectionObserver` 实现图片懒加载。

#### HTTP/2 + 缓存策略

- 静态资源合理配置缓存策略；
- 可使用 `service worker` 或 `nginx`/云服务配置缓存。

#### 优化 HTML 结构

- 将关键 `CSS` 内联；
- 将大体积脚本延迟加载，使用 `type="module" + defer。`

### 推荐插件汇总

| 插件                        | 作用                        |
| --------------------------- | --------------------------- |
| vite-plugin-cdn-import      | 引入 CDN 脚本，减少打包体积 |
| vite-plugin-compression     | 生成 gzip/brotli 压缩文件   |
| rollup-plugin-visualizer    | 打包体积分析可视化          |
| vite-plugin-imagemin        | 图片压缩优化                |
| vite-plugin-pages / layouts | 页面与布局自动化配置        |

### 扩展问题

#### Vite 与 Webpack 的构建机制差异？

| 对比点        | Vite                             | Webpack                                |
| ------------- | -------------------------------- | -------------------------------------- |
| 构建原理      | 原生 ES Module + 开发时不打包    | 一切资源都打包成模块                   |
| 开发启动速度  | 秒级启动（仅转译当前访问的模块） | 启动慢（打包整个依赖树）               |
| 热更新（HMR） | 基于原生模块，模块级更新更快     | 基于内存模块依赖图，更新速度较慢       |
| 构建工具      | 使用 esbuild（Go 编写，极快）    | 使用 JS 写的 loader + plugin，性能受限 |
| 静态资源处理  | 靠浏览器原生能力 + 插件优化      | 通过 loader 配置统一处理               |
| 插件机制      | 基于 Rollup 插件                 | 自有复杂插件系统，灵活但学习成本高     |
| 上手难度      | 简洁、默认配置开箱即用           | 配置繁琐，尤其是复杂项目               |
| 构建产物体积  | 与配置相关，略优于 Webpack       | 得益于成熟插件生态，体积控制强         |

#### 如何让 Vite 支持旧浏览器兼容性？

1. 使用 `@vitejs/plugin-legacy` 插件

```ts
import legacy from "@vitejs/plugin-legacy";

export default defineConfig({
  plugins: [
    legacy({
      targets: ["defaults", "not IE 11"],
      additionalLegacyPolyfills: ["regenerator-runtime/runtime"],
    }),
  ],
});
```

2. 配合 Babel 转译语法（可选）

- 适用于部分库内部使用新语法或第三方脚本兼容性问题。

#### SSR 项目下如何优化首屏加载时间？

1. 预渲染/骨架屏

   - SSR 预渲染后直接返回 HTML，减少白屏；
   - 添加骨架屏占位，提升用户感知性能。

2. 资源预加载（preload/prefetch）
   ```html
   <link rel="preload" href="/main.js" as="script" />
   ```
3. 首屏组件优先加载

   - 路由懒加载只对非首屏组件使用；
   - 使用 async setup() 控制数据拉取时机。

4. CDN + 静态资源压缩

   - 使用 CDN 缓存稳定资源；
   - 启用 gzip/brotli + HTTP 缓存头。

5. 渲染流式传输（Stream SSR）

   - Vue 3 + Vite 支持 renderToNodeStream；
   - 实现 HTML 流式分段返回，首屏更快可见。

6. 避免阻塞脚本 & CSS 内联关键样式
   - 样式内联减少 FOUC（无样式内容闪烁）；
   - 延迟加载非关键 JS/CSS。
